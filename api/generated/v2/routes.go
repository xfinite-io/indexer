// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /api/v3/rewards/get/balance)
	GetBalance(ctx echo.Context) error

	// (POST /redemption/api/v2/coupon/getRedemptions/transactionid)
	GetRedemption(ctx echo.Context) error

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetBalance converts echo context to params.
func (w *ServerInterfaceWrapper) GetBalance(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBalance(ctx)
	return err
}

// GetRedemption converts echo context to params.
func (w *ServerInterfaceWrapper) GetRedemption(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetRedemption(ctx)
	return err
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"include-all":           true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"round":       true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
		"limit":       true,
		"next":        true,
		"creator":     true,
		"name":        true,
		"unit":        true,
		"asset-id":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"include-all":           true,
		"limit":                 true,
		"next":                  true,
		"round":                 true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/api/v3/rewards/get/balance", wrapper.GetBalance, m...)
	router.POST("/redemption/api/v2/coupon/getRedemptions/transactionid", wrapper.GetRedemption, m...)
	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET("/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"4fN/BwAA///berNCwQEBAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
