// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (POST /redemption/api/v2/coupon/getRedemptions/transactionid)
	GetRedemption(ctx echo.Context) error

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetRedemption converts echo context to params.
func (w *ServerInterfaceWrapper) GetRedemption(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetRedemption(ctx)
	return err
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"include-all":           true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"round":       true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
		"limit":       true,
		"next":        true,
		"creator":     true,
		"name":        true,
		"unit":        true,
		"asset-id":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"include-all":           true,
		"limit":                 true,
		"next":                  true,
		"round":                 true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.POST("/redemption/api/v2/coupon/getRedemptions/transactionid", wrapper.GetRedemption, m...)
	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET("/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
