// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /api/v3/rewards/get/balance)
	GetBalance(ctx echo.Context) error

	// (GET /api/v3/rewards/get/transactions)
	GetTransactionHistory(ctx echo.Context, params GetTransactionHistoryParams) error

	// (POST /redemption/api/v2/coupon/getRedemptions/transactionid)
	GetRedemption(ctx echo.Context) error

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetBalance converts echo context to params.
func (w *ServerInterfaceWrapper) GetBalance(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBalance(ctx)
	return err
}

// GetTransactionHistory converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionHistory(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"limit":  true,
		"offset": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionHistoryParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := ctx.QueryParam("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionHistory(ctx, params)
	return err
}

// GetRedemption converts echo context to params.
func (w *ServerInterfaceWrapper) GetRedemption(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetRedemption(ctx)
	return err
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"include-all":           true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"round":       true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
		"limit":       true,
		"next":        true,
		"creator":     true,
		"name":        true,
		"unit":        true,
		"asset-id":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"include-all":           true,
		"limit":                 true,
		"next":                  true,
		"round":                 true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/api/v3/rewards/get/balance", wrapper.GetBalance, m...)
	router.GET("/api/v3/rewards/get/transactions", wrapper.GetTransactionHistory, m...)
	router.POST("/redemption/api/v2/coupon/getRedemptions/transactionid", wrapper.GetRedemption, m...)
	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET("/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
