// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (POST /redemption/api/v2/coupon/getRedemptions/transactionid)
	GetRedemption(ctx echo.Context) error

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetRedemption converts echo context to params.
func (w *ServerInterfaceWrapper) GetRedemption(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetRedemption(ctx)
	return err
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"include-all":           true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"round":       true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
		"limit":       true,
		"next":        true,
		"creator":     true,
		"name":        true,
		"unit":        true,
		"asset-id":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"include-all":           true,
		"limit":                 true,
		"next":                  true,
		"round":                 true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.POST("/redemption/api/v2/coupon/getRedemptions/transactionid", wrapper.GetRedemption, m...)
	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET("/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
