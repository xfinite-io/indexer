// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (POST /redemption/api/v2/coupon/getRedemptions/transactionid)
	GetRedemption(ctx echo.Context) error

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetRedemption converts echo context to params.
func (w *ServerInterfaceWrapper) GetRedemption(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetRedemption(ctx)
	return err
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"include-all":           true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"round":       true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
		"limit":       true,
		"next":        true,
		"creator":     true,
		"name":        true,
		"unit":        true,
		"asset-id":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"include-all":           true,
		"limit":                 true,
		"next":                  true,
		"round":                 true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.POST("/redemption/api/v2/coupon/getRedemptions/transactionid", wrapper.GetRedemption, m...)
	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET("/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"fnEkd/3p+r8DAAD//+/3TzFy/gAA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
