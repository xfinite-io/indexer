// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /api/v3/rewards/get/balance)
	GetBalance(ctx echo.Context) error

	// (GET /api/v3/rewards/get/transactions)
	GetTransactionHistory(ctx echo.Context, params GetTransactionHistoryParams) error

	// (POST /redemption/api/v2/coupon/getRedemptions/transactionid)
	GetRedemption(ctx echo.Context) error

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetBalance converts echo context to params.
func (w *ServerInterfaceWrapper) GetBalance(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBalance(ctx)
	return err
}

// GetTransactionHistory converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionHistory(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"limit":  true,
		"offset": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionHistoryParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := ctx.QueryParam("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionHistory(ctx, params)
	return err
}

// GetRedemption converts echo context to params.
func (w *ServerInterfaceWrapper) GetRedemption(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetRedemption(ctx)
	return err
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"include-all":           true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"round":       true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
		"limit":       true,
		"next":        true,
		"creator":     true,
		"name":        true,
		"unit":        true,
		"asset-id":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"include-all":           true,
		"limit":                 true,
		"next":                  true,
		"round":                 true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/api/v3/rewards/get/balance", wrapper.GetBalance, m...)
	router.GET("/api/v3/rewards/get/transactions", wrapper.GetTransactionHistory, m...)
	router.POST("/redemption/api/v2/coupon/getRedemptions/transactionid", wrapper.GetRedemption, m...)
	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET("/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{
	"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",
	"R0r0ixO5zz9+/u8AAAD//xJhEDXXCAEA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
