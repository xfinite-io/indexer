// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (POST /redemption/api/v2/coupon/getRedemptions/transactionid)
	GetRedemption(ctx echo.Context) error

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetRedemption converts echo context to params.
func (w *ServerInterfaceWrapper) GetRedemption(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetRedemption(ctx)
	return err
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"include-all":           true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"round":       true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
		"limit":       true,
		"next":        true,
		"creator":     true,
		"name":        true,
		"unit":        true,
		"asset-id":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"include-all":           true,
		"limit":                 true,
		"next":                  true,
		"round":                 true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.POST("/redemption/api/v2/coupon/getRedemptions/transactionid", wrapper.GetRedemption, m...)
	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET("/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"HQAA//92n2XZZP4AAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
