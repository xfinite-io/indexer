// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /api/v3/rewards/get/balance)
	GetBalance(ctx echo.Context) error

	// (GET /api/v3/rewards/get/transactions)
	GetTransactionHistory(ctx echo.Context) error

	// (POST /redemption/api/v2/coupon/getRedemptions/transactionid)
	GetRedemption(ctx echo.Context) error

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetBalance converts echo context to params.
func (w *ServerInterfaceWrapper) GetBalance(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBalance(ctx)
	return err
}

// GetTransactionHistory converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionHistory(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionHistory(ctx)
	return err
}

// GetRedemption converts echo context to params.
func (w *ServerInterfaceWrapper) GetRedemption(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetRedemption(ctx)
	return err
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"include-all":           true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"round":       true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
		"limit":       true,
		"next":        true,
		"creator":     true,
		"name":        true,
		"unit":        true,
		"asset-id":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"include-all":           true,
		"limit":                 true,
		"next":                  true,
		"round":                 true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/api/v3/rewards/get/balance", wrapper.GetBalance, m...)
	router.GET("/api/v3/rewards/get/transactions", wrapper.GetTransactionHistory, m...)
	router.POST("/redemption/api/v2/coupon/getRedemptions/transactionid", wrapper.GetRedemption, m...)
	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET("/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"yH3+8fN/BwAA//+tBdlncgYBAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
