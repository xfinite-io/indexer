// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /api/v3/rewards/get/balance)
	GetBalance(ctx echo.Context) error

	// (GET /api/v3/rewards/get/transactions)
	GetTransactionHistory(ctx echo.Context, params GetTransactionHistoryParams) error

	// (GET /e-store/api/v2/get/order/history)
	GetOrderHistory(ctx echo.Context, params GetOrderHistoryParams) error

	// (POST /redemption/api/v2/coupon/getRedemptions/transactionid)
	GetRedemption(ctx echo.Context) error

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetBalance converts echo context to params.
func (w *ServerInterfaceWrapper) GetBalance(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBalance(ctx)
	return err
}

// GetTransactionHistory converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionHistory(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"limit":  true,
		"offset": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionHistoryParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := ctx.QueryParam("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionHistory(ctx, params)
	return err
}

// GetOrderHistory converts echo context to params.
func (w *ServerInterfaceWrapper) GetOrderHistory(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"limit":  true,
		"offset": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetOrderHistoryParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := ctx.QueryParam("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetOrderHistory(ctx, params)
	return err
}

// GetRedemption converts echo context to params.
func (w *ServerInterfaceWrapper) GetRedemption(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetRedemption(ctx)
	return err
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"include-all":           true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"round":       true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
		"limit":       true,
		"next":        true,
		"creator":     true,
		"name":        true,
		"unit":        true,
		"asset-id":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"include-all":           true,
		"limit":                 true,
		"next":                  true,
		"round":                 true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/api/v3/rewards/get/balance", wrapper.GetBalance, m...)
	router.GET("/api/v3/rewards/get/transactions", wrapper.GetTransactionHistory, m...)
	router.GET("/e-store/api/v2/get/order/history", wrapper.GetOrderHistory, m...)
	router.POST("/redemption/api/v2/coupon/getRedemptions/transactionid", wrapper.GetRedemption, m...)
	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET("/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+x9a3PcNrbgX0H13qqxZ5uSYyezG1dN3XLs8Y1rnMRlOZmqtbK5EInuRkQCDABK6nj9",
	"37dwDgCCJMhmtx52Jvpkq4nHAc4DB+eFD4tcVrUUTBi9ePphUVNFK2aYgr9onstGmIwX9q+C6Vzx2nAp",
	"Fk/9N6KN4mK9WC64/bWmZrNYLgStWNvG9l8uFPut4YoVi6dGNWy50PmGVdQObLa1be1G+vhxuaBFoZjW",
	"w1l/EOWWcJGXTcGIUVRomttPmlxysyFmwzVxnQkXRApG5IqYTacxWXFWFvrIA/1bw9Q2gtpNPg7icnGV",
	"0XItFRVFtpKqombxdPHM9fu487ObIVOyZMM1PpfVGRfMr4iFBQXkECNJwVbQaEMNsdDZdfqGRhLNqMo3",
	"ZCXVjmUiEPFamWiqxdP3C81EwRRgLmf8Av67Uoz9zjJD1ZqZxc/LFO5WhqnM8CqxtFcOc4rppjSaQFtY",
	"45pfMEFsryPyXaMNOWOECvL25XPy5MmTrwluo2GFI7jRVbWzx2sKWCioYf7zHKS+ffkc5j9xC5zbitZ1",
	"yXNq151kn2ftd/LqxdhiuoMkCJILw9ZM4cZrzdK8+sx+mZjGd9w1QWM2mSWbccQ6jtckl2LF141ihaXG",
	"RjPkTV0zUXCxJudsO4rCMM3tceAZW0nFZlIpNr5RMo3n/6R0mjdKMZFvs7ViFFhnQ8VwS966rdAb2ZQF",
	"2dALWDet4AxwfYnti3i+oGVjt4jnSj4r11IT6nawYCvalIb4iUkjSiuz7GiODgnXpFbyghesWFoxfrnh",
	"+YbkVOMQ0I5c8rK0299oVoxtc3p1O8g8dLJwHbQfsKDPdzPade3YCXYFjJDlpdQsM3LHWeWPHyoKEp8u",
	"7cGl9zu5yLsNIzC5/YCnNuydsARdlltiAK8FoZpQ4s+pJeErspUNuQTklPwc+rvV2F2riN00QE7nULWa",
	"ydj2DTYjsXlnUpaMCtg8p6VktCwn5GVZEm5YpZ1SY0UjTFAEUbokBSsZLLI9DuBXbZTcwuI1s+1kbViR",
	"ycY4otjI0g6ol4ARHBY/R4dPKXNaakMNG1WI4pXsWHTJK26Gy/2OXvGqqYhoqjOmLMK9bDWSKGYaJcYm",
	"xxF3EGpFrzIlG1HMUDkMkSoW6bpmOV9xVpAwyhgs7TS74OFiP3haRSgCxw8yCk6YZQc4gl0lkGKZy34h",
	"NV2zCCdH5EcnW+CrkedMBBFEzrbwqVbsgstGh04jMMLU08q+kIZltWIrfjUE8sRth+VvbOMEYOVO31wK",
	"Q7lghZWNALQ0DGXFKEzRhPuqGGdUs799OXa+tl/laqVZYtN/gN8JF1babBgB/JHLDVPdK8qGayPVllxS",
	"p0upalyyu8l2UIFi52yblOJ9msQdDtcsC6brO72xYYYdUmIma6xknyUm2WEWK0CjDOVQ4lgHbLivyStt",
	"p/+MS208t+brDH8eUDlfv7Mn4YqXcEr+aonbb0Oj7anQ3Qh/bmq+FtQ0ij09FX+1f5GMnBgqCqoK+0uF",
	"P33XlIaf8LX9qcSfXss1z0/4emQzA6zJmyF0q/AfO176JmiuwnJTU/jPqRlqahues61idg6ar+CfqxXs",
	"Ol2p3xd4xxqbOXUNei3leVPHO5l3eO5sS169GKMuGHJKkAGH6VoKzcBw8QzP77fuN/uTlVVMgFSIjuDj",
	"X7UEFbMdu1ayZspwFpth7H//Q7HV4unifxy3Zptj7KaP3YStVm/GziAkc2ocoyODO9a3gsgO3hiUN0lB",
	"4on+fYCtP2eLFnn2K8sNblAXjAesqs32oQXYwa5vbrfg/6Ba7bFvDmSqFN3e8j7iqZzB6Toc+UerAVr5",
	"V9M1F7DwpT0lBKnouRUHVEizYYpYXDBt/PmMOi0e2cF+5A55p+ceLVIck8CpvjZSW6zdBF7btjsxGjW9",
	"U264qe3SN7tfe/BCd+fu+QH4Id7J6/KEvZl9Q0sqcnYTWD5zQ83G8HdccADiW7wd3qPZozls5U2g+CYY",
	"WLsbxCTDQqO7PfI1Xjauv0n6pnZpDwHn9+ue5gMur03x35QyPz8Il1OoglF3zPxfQZjeACnlskjczfxs",
	"KbwW1NCpHklZPWMKd78ckVAJ9CwXFdOarucMPkIKsHq3pHa4OZTwzhIi12QdkEFozYm/DRFtVJPbS6rD",
	"2A+qYOpbNHB8lmgLkmQeXtHqv8fOLxc5NWwt1faX1D11qh/au5/tN9uek/CKrpme0aWlPsNNyfaapKmL",
	"vVfSF16Vv3pGuxnvEaw8rMdDGc+d4qT+yfAJOasr6d6ywv59M9ep2xZ2s5nCy7rlIpdNLcUvZ4qK4pdS",
	"ruV+rBH3RqPN/r1n7kqiX1VTsT2ka8EM5aU+qCvX+aG7zK5qrg4CeCMvfzHyF8UKxqpDBthX5rleO6XS",
	"nmL75sYdgDxQLnEqq7bJW51qIHniJfbhmCP8XA8j8v2kuxVx+yF6VLgPpEKK17scPODLAbcNeajPGSP0",
	"HlPxcmyD7XZFm/CZ6WvdU+VdawH/N9LJnCL6aj9Rc4gmV0rNxfqX+cp9LNn4AdKQz5FZA3qDfgcci1z8",
	"kvZZ7dZS9yOAO1Ft917KDaipLSkuI6nWI5uWGLoojhEXo6Pd5ITC61r8YdTc6AI5lEYTd8lvGS3N5vmG",
	"3YL1IRp7hwyNQL4JyXmbdqjI27lr/dGqdrg5usPueQBF0+jPffc+HyteZ8vnGz87ON2lOo7jWO+H5I/e",
	"ax67xRNByi6hgAsMp+FSWExRF3OLoR+n4lS8YCsuuP3+9FRYaXN8RjXP9XGjmXLC9mgtyVPihnxBDT0V",
	"wxvqWJIBhFU6aOrmrOQ5OWfbffSF09P3tFzL09OfiZGGllHgWxQF6gKWWhf6kORwgsxShmxM5qKnM8Uu",
	"qSoSoOsQLgUjYzjq1KxL4sbGqC4Xne3GT7MBrWudQdhgBnGD6eXXdWmXH/vOMNaQWJQRK9p9zBbXHhrA",
	"7/fSuKAjekmQvkijmSb/XdH6PRfmZ5KdNo8ePWHkWV2/tmOeWDj+2wUMWX7a1hjHuafPsx0sdULCwgGf",
	"GbsyimZ1Wgs7PX1vGK0B+xtGdFNBiGtZEujWCb+slVwrWkEMnm4X4PdjHAEIx7yzLFohLO4Ee/mcgfQS",
	"4BOgENqQDStd9N818BU5Hg9G1w7n5USWwunpe0hA8JgJActryoX2p4Lma2GZwMV2nzGSWy2AFUfk1YqA",
	"VFt2ursMIycxg+jgGsOxCag3EDhHciogTBs1M0v+VGz7QUiaGeNDvt6yc7Z9F8Xd7ZkH4aJ+6Y4jsWjs",
	"cOFYbDEMAYiVhHC0nAlTbl0gcYI008A0XBiMiXR6ambpd0xoANdE8eKWcWIR4sboE2IUPk3rmqxLeeYk",
	"TSDRp4FGfZ9xofLGAqBvQKAkTSp+GyZ4r6YqsRHIiCNbcMBC7XjXYsPJ5R1MciuuNASpM+rOCBqzyAGU",
	"5yLoh6D8a8NAK5OKCGl6JKU9S6eIPsSzLhc1VYbnvJ4Xm4Sjv+n0sYPsOtqTh7lc9c/swZGaPEKwcXZG",
	"dfr4ZvaLpcBGY3aFXaMXdH4m1JZhBUcEMjMdq56VkHARksEQx1RBJohfNiZHjYGW5gumRKtTeTC6OxIr",
	"bxuqfVII5M54ETFLzRkh3nchaNvyTUS9sd7K7bwlu6Bj+z8eCvxKFFZ2MN1NkAmBvv5Y6bP/MkTEY9Kr",
	"Dwj2UcA+9Hex3CuMd7mwOl6TRocUoONZ7lrjwrGxJxQH2l90hCALxw+rVckFIxnhYbUGVosJTTLnmNXT",
	"cqKbg9krwF+JpTY7wOwRUmQcgV1LWeLA5HsZ86ZY7wOkYBykCfVjg1iJ/mYzIjJC9nGwFe24BAxlR8tE",
	"yzYqHtGYsgQlRdLY/azTimCTM3ffiI6rFIla0ZTbC77QDSS1GZnL8mhwMdOsZCDps45kzewlLKnTMSDD",
	"E98turSRB3xlVayHkShXbM21Ycpd2AHCkFjQpnJsDbOQUWOYshP93wf/+fT9s+z/0Oz3R9nX//P45w9f",
	"fnz418GPjz/+/e//r/vTk49/f/if/5G6P15IwzI47rILWqZsmaen722jlxpU8ZdwMibFT2erCGYd8hFD",
	"Bkx7zrZZwcsmjW037z9f2Gm/D7dX3Zydsy0cMozmG3JGTb6BU6gzvW0zMXVJdy74NS74Nb2x9c6jJdvU",
	"TqykNL05/iBU1ZMnU8yUIMAUcQyxNrqlE+IFbp4vWJly88TZ8GBTsALT0KMpm82AmQo/9pT6FUExLnlx",
	"pORaukHo46vgomBXkHfJTZRkqode6JnqMtgSUZpG00B6GI5w62pxvLpYNXajpHVj9/EayxsOP3d5I+KF",
	"1jUvrnrGKURYWnwA9va59eH1cUBgwDhusB3EFRmihsliRirmjWnILZE6gpnYIl7bkI3aXOB5iPEHuEtN",
	"lk1QonrT3BoBsmHSslt7ihbJSskKOG94C4qIk4/o9x0SbI+c3qyutsqQXqzwhJz/nfZ4Rst/su1Pti1g",
	"FTJHIYubi7ks0153oGebWno91FzPspiifDfiDsp/E5gtSfVQhAOtOx1HwZ4MQOtayQtaZs7+OiYolLxw",
	"ggKae3PtHZ/paVy9+8ez128c+GDpY1ShRX5yVdCu/sOsyh5uUo3wqa8aYa9l3izWP0Sc/ZXrjs3WZVx3",
	"Ly32uHbEhVze2uMjieBsuCuv3O1pkXWuA1zihAuB1cGD0Jp+0IHQdRrQC8pLb3Px0KYlEy6uddvsLZzi",
	"Aa7tfIh8SNmNipsBd6e5Y4ckimeYqEtQYW0LTaSrPxAuS3BDAgMOEGhFt5Zu0PM1FEmiqTLLdJkueZ62",
	"yokzbUlCoEPJNibQeOSuZUe0Aj09VsOjsWwzPSP3pwdkNEdyM3WyBkK7d2fSebwbwX9rGOEFE8Z+UsCL",
	"Pfa03Ogr4xysRyfMzlhB5w41aZhwHx3aVXq51uLCKIdo0lY5Hk7qsObWE3B3HSXaDjWmPgMQ0xp07Bsc",
	"gPsiGKs8FQWnJhUdN8oeIQbxjHNj4K1u4ZjPiYpGcOdiPQA7uwu/eW3dVQQ6Gg/ASx21z8aPWTv+Hgds",
	"e54CYPFJikWKaKllYphGXFJhfKkjt1uut2ZoWbS9LqXSBmpjJYNm9rpuxCWUrnXJ0NlKyd9Z2si2snRw",
	"OZw+mhh7pweffVnoSYaRS0PAzDih7CLGUITquiCFS+a1gRqLLI/qHnraj9E1KmDGrijRR9INxBk5xEDW",
	"RO5euNF5FwUVKFyeQyXFjgM0LaLiCK1jHL8VUQ7moSGAXp7R/Dx9U7AwPWuDHDrOFCOJ7xwKjXXxdUSi",
	"eInQlmug8ZqpipvukdcLID5A6/+jiaOcV7RMq/8F7P67jkJZ8DXHmmmNZlHNMDcQqSUXBqmo4Lou6RbD",
	"SNqtebUij5aRfHPYKPgF1/ysZNDiC2xxRjUoZq2tx3exy2PCbDQ0fzyj+aYRhWKF2bhidFqScDMDU0nw",
	"Xp4xc8mYII+g3Rdfkwfgt9X8gj20u+jU7cXTL76GOmv4x6NkSgFWV5wSvwXIXy/+03QMjmscw6oKbtS0",
	"PMb6uOOSfoKbsOscXoKW7nDYzUsVFXTN0tFQ1Q6YsC9gE9w+vX0RBdZzBMWScJOenxlq5VO2oXqT1oUQ",
	"DJLLquKmsgxkJNGysvTU1rzCSf1wWBwSZX2Ay38EJ3lN0oawu3XxpVMu7KohlOF7WrHuti4J1UQ3Fua2",
	"3J4TiEfE1UgriBTlNjIBwt7YuUBVsYo1GGpXpFZcGLAONGaV/W+Sb6iiuRV/R2PgZmd/+3II8jdQ244w",
	"kUs7v9gP8Dvfd8U0UxfprVcjZO+VLteXPBBSZJWVKMVDJ+W7XJmMzJaGlumgUC/R+zHB00PP1bzsKNko",
	"uTUdcqORpL4W4YmJAa9JimE9e9Hj3iu7c8psVJo8aGMx9OPb107LqKRiXSP3mY/T7ugrihnF2QXEp6aR",
	"ZMe8Ji5UOQsL14H+0/rJ2xtAUMs8L6cuAlicZLgd9ud42WPmBCnPzxmruVgfn9k+qKrjqH0lfc0E01yP",
	"H6DrjaUc+9keeZH1B4YmZ6yUYq3vntI94COO2DUDmfTqxS6oBwP76rMZNB3fGNvOTvHGV6vFoW37T3Ei",
	"hcDGnWVv3rq243GI9hjDSPbnLu4cw2S6Lktc7yUFnwATBap1IP42lIuR4ETGipFAKwYznkhlOAZrMPYJ",
	"wqYMr5g2tKrTxywYyZETgastoKGLvY1olktRaKK5yBlhtdSbXelyI2keVwImK7nGIyd+kSSXCtMWQacw",
	"spfKNDfQejJpqwtjpqQ0Y4CC8hFn20lpCG3MhgkTwhsZFEbvrwRDseHGgQcKiizynZXxvpQqLcvtknDz",
	"F+0KG0s0Y5CKqfOSEaMYI5cbqRkpGb1gbRV8GO0vmry74oWGGvclu+K5XCtab3hOpCqYOiIvXTlguAVh",
	"JzffoyPiklBceOa7KwHLKyTDK1K8Tlymj6cNfpt4xUs8QPs/Q+l4zcoLpo/Iu0uJQOg2cU9bJaTT46wx",
	"GMBe8NWKAZ/CcuDyBP3aDxFMUM8fXhUIw7o1fQJuuxIZ6Mcjl0iDloor8RwbERf13XWG9VijwhurJ6iS",
	"FWumlmhShW3nFWsTNa3uJpVpDTYrhsHQVrJxYZQsmpxheuBJhx4jsPgApFDiPMq/ARryzym0cHpji5ep",
	"9kIOCu4jVLOE7K4QcMcumCJnjIlooAcodCK4tKEK8jkYZB3hUlnxMC2cm3qtaMHm+XBBCP6IPUJamx/h",
	"Qu43wE+2fV9t6ugmnRM/fUpHAckMktdbWZ6SZaOq19uxLIGX+EqEYiWGb8MDA9B2OVCsVoxlmou09XPF",
	"GMh2muestuQcPyDFmBVUqMSCqIC8Mn+2WgwLwy8YBpZPKANZTsu8KTGAcuKkv8xpqbouo5KtjLQEFr8r",
	"0poEuZ3rDAI4sbY/zqesAIx6WI6yZLp1LfD25EvpW+ZQvTiHYapGVrILlr7TMIoZG9/KS1JRsQ24sFO0",
	"YCyRX4BVAuSoq4ATHbH9o7vYReAjMzmqmwbSomJkc4sYzzVTXBY8J1z8yhw3B7HkKQZf1JDCcNHAQySK",
	"tXDjOUEg+aSfYDKkADWWQms/dKOvBbvsYLuI9LlurLI29Jwh2D5Nxh2Nc3GqmOZFM2LKVDTvQrYfMTrm",
	"fUsNO1YBtfqG6LInoQKTTzFdn5Z7ZNPD1nCXRuVUR/jOEVY0JEYQJ6gT4ZsuN9+3HLn7SCO9xcnnpoax",
	"L5jS3cDAyAbIrnaMbVt0xseKBUqifWH/WTIfsqNH59uiOG5pzitfmFwG/ZmLGUns4Eg5hwCAvuQm32Qj",
	"uRC2LbawMLzt37SGU6IKAVzIViuWmzkwQFA9Pk0zCgV+tlC8YLSALKg2PwIzI/qgPPheEju0jvQaoTlo",
	"oa1aA6M83KPIeaCQXcT/k5xJ+xcS/gcu0hls4BUZh/u02RPbOOJpk+so2TINuxKeGYl4pJaalmkPj5+0",
	"YCXdTk0JDbqTBsXWO7nwzMGKqaIg7IrlzUi8bjS147OpyW2T/oIDew65In46o4/JfyglVVyapef0FoTZ",
	"Fm2JHrjVSPjuqz2E7PUuAn3Nr6niaNNWu/EqQ8vFPy5oOZJv8pbVimmr6RJK3v3j2WvnhBzLOslHk6So",
	"cRmQhpLR9OSPS7ippWUbxvTBd/dSXNIAOxbHh2F89vOg92HREWNlfKIN9WGhQ4D+6UPfSU2587C3KTfD",
	"nXVpWMPEuDnh8y2C+4twyU0wSGolcXGnIUWTDXzGsg+Brvcg3+IsC0G5qSeQlgtgmW7hnp1FJLnOKr5W",
	"IC3To46zTWRG3CHdO7D3Jm1n8OOlNnfwwkBihzWv6hLduk5HsCd63IvslfvVRtrdfuDmTceE3XpUFzvY",
	"pXjzwVyHwrI7S3o6cOsH8VxWdcnGBXmNDnl8nRLPasjAp0XB3VnmjTsyzxvVWv36oVk/0ZLjE10asvCF",
	"lLX9156Jwv4H0qhkY/D/jCr7H6wJ0/0fUlWUsm+HWgBeuHBVBO1APsA9FP1beMpOpvQfmIo5y1w9PCQS",
	"omwytL5zOANmSjSyt+kClivhyxq+xFkJBAGB8BDt/9KkYIapymrLG3lJqibfQCA+XTMflw8xL2Cq7U3U",
	"Gd2H73XzS5y7U9c0x4EwJKqkas0UcVFKxNV6DKFOFeW9twv7gQhweaapg3NXtsDwxU1Qc6KcgURSggfj",
	"nG2P8RSH3w8QHOOpByOAQQLCLYJ0rTyGOBVmB72edxQgLPDUyR4K4N+gImThc7y2pyI0TPKZuzxYB7BD",
	"o9lwnfPdW/HeJkRFu7a5Wvxwc8eVb3M2R/lOV2qx3UH7xw3x1ZMS97a70t1xnW3911F67pYB7T/pDEJJ",
	"Q8E69+ZyLqtKCjBPlWXPNygKAtFSGh5hFoSJC1bKmiVbwybNCF/WfC1YYa4ExkWcwJ/vrkSqbXz8Quto",
	"eamyj9Gj+ofVQ+3V98Iwcnzw/tAR20DvdkQMCL3OiC8xGjWMCEOtmLrOmO/cGDNK7a2FwgxGDMfmPjgJ",
	"FCfEcJc6QsCSL8Hnw66DH5f91tDS+akFeIXfQehxfs4EVtdrdKipSpjQjXJuYQsrjGdBccPI+NDVbZND",
	"6+xlU7WrFJjMgzXeBaNBGD12tepAYZEjp2t3udLR2UR2UQ7pRa6hTx8FO9dkGTUo+O3eGp6Zex57xQZv",
	"FY8W+c5iJhxJLotefhbDSg3kwasXDwmUYRkriOEVdK5nLDuuyTcPIoxwHMDSTybcB4oVY2OuyF70Blmx",
	"kcNmVzWh1UVbSAha9c3HO6GcGY72LdVQGcg1d27zzzQGrQOkewV4OFSc/Lx3tZnlYq1kkw5ZWmNCfi+Y",
	"EpR1UIQwkEZv6FdfPD5+/NXfSMHXTJsj8i/IGEItaFinrItNwtv6Z52CigQACxm3qM64aIlozo1D6CAq",
	"hruoCRjm7jGcrOIRre7Vi2QvYRRFIZcd9Fh7f3dnSD98z/rA0/ef+Bj2x+ViR/ms8iJUzjqMwUs2Vhay",
	"vEqQ6ZPHWUupR+S17U2YWEllb5lVY+xZy64giQftfDH1YGaLaUvkQlKL+J0pCZdoQaS9M/fPGh5tNkRi",
	"0Bz0YO3CiSwMISM5xHw/OAGtYYlAPsQ72pCkSSMMRzXDbuNP0S7WVsBboP+14WWCCmppv+sYjiURkmDx",
	"97glxs21GVoIs4uK7hDS3bJTXJWhSNuILCVAzMTrqCJOe0PPN1S01ay75XQwyAkdXVGFwB5N7vNud1fG",
	"9q+PQo5EVwhX6M3qyJBGFAwtd7vdNd1WTJgDhcIb7I2BG1DoVE0roWpECfW9d5WNPWfbzMj02PZjSGMN",
	"2j6Y1FAQRWtcjqjewUXtS2S36hMSlz2lVg0E/0Xxkt6k5m4VwTR7zrZEeTNBXJESNfcDFH08MQxPpdm8",
	"4xVrVWPUJVKnMJ91WuANJ321wshvlGZ/mVhOGGaaKvQIVWDfaZoIWNiDbE9CH4gvzcYNLNuadf3Ynaq4",
	"3cBNuGYekRchoBZM8Bha1kbZokmjb6jHtNSQJcyVN31Q5U2RYMs/PX1fo1s/wbiuAR7zts3wwHdNaL5a",
	"h9r6CduBb3a1Yqptl7q/+5Yr9XvbcGg68M2GzzJ0JE/raajpduE1lsVyYQG2/1iA7L8r9fsCXiIohx6G",
	"NA85NGcwQSJIa9G9u7injDpFJx1HxDTXks8OQ9dk5UYXiwLG/eiw6ugpc5LuI/snpt63PzynZfnuSuBM",
	"iQgDFIRjrikshuqyDILUtKLVeae8McNxbGxIp3luNZKijWKM4PyLJv1qSRjbOKyX1DmY95Saiac0Av1R",
	"tR5dN9gxhloTzwlV66ZC2+/tr2/HCkYLTfLCJTgNqyU6TQhZv1GsIFK51Aa+cnkrY5VaZlavwydIXss1",
	"z1uNqw2sHKH0pdXVWe3qCEiR5cFxas8ueyEykpyiw/F0cUReYRi0YrRAIaq4Yak6ap31Q07mJStLMBsj",
	"RWcBu1GpxSPLRZ06dRooWzF4aaTvgP0DV+ajtW5GMDYmlVywVQdJnwBDz+1MbqSApJwKIc0fCE97Vubr",
	"vbUUhQnUdSjRVzLhn/xCXRiGHTHdScX4Wky9j7Ki/iDQfXQlj4OulHLpVzHi9eCUCCryYUIUDPI4GD6D",
	"QItMinKbkq5xql1PvIa9mHwkJSTf6Ta0RLtVRnVe5i3Ri5k30QqBsOGG+eZm13dAIcVrV0/sDdCRGrv6",
	"duJnEvUW47OwP/QuzSxyfk1qZlh0pLQLR/mkWObPTy+xRIH1SJo2HOdUPCO/MyXdBTIMZRmiNZm6pHSX",
	"L3qU6BSKB+lBt/6UexZnwsVPaIejBd5OT99f0YGWATBdQ784rFbfThy/HCmOE+PYe1BcNZxrVr3CGSc2",
	"duwJwNPT9ytaFL06IXGIDgqZUOcCd9tVCQJioZcjBXkmsbmaxObE+J2kgkt/A5x4vMXfGDF949LvOPZI",
	"hS2Oh+C1ddSGU89h/uBTnkUa/hZ8XeLws06Qx0T9RlrBnexZKM3rgJMBviPiRIjzv/rflbetlCsvzbzL",
	"xjsVe6/nPMNzraL1jVaH3Ck8IojHXdFs1BHdpuq4g9mPF1UhgAFaj3f/jZ7rPfvlR09jEL72EzRoXKKk",
	"fQFQsQqyi9orZgI5rrRZUAvbmnPo3AdffBxCrKMZ4r0m5JUdmZaXdKu97bQlrPHh/K5iLZOE3S5OP0SD",
	"b3pvVA5OpLcs5zWHRw27UjDQ+LjFceRRSbRcWqGDeVH8IhgtXAwxbYsFdh1F3k/kyp7R6IBeum2mZdda",
	"gAN767Bt89yP7VcUUBqdZzOeaUoUkQxbukPmOU/epLBzpsN9ZRz2QiGH04xLN9F/E2bETyJsI4u076g6",
	"75yBVHcfdMNg+c6oHRUjCnE/4I0n51140z7DAyG7wdb/E1Po7HtLRSEr8rIRSAUPfnr78qF76NkTmU/I",
	"t8TnIPmMn39aDZ9/SjyCZLfkph5+Oi8+0cNP5eDhp8NXOv/JJ09bYw8++eBw9CetuTYqYSK++wpWU2LG",
	"+wan5YxzY+wraFw3lDRupsMUKdSjRh7INqFmUe+IvJY60nkukhp8+127upOtWtINyWsrwIoQWRdZ3HeG",
	"7HXHG3maw2kkMAkUrku8Pajd65VeCkfvFOPzPFi5tozUhFUjCt3bwva1iAnn4aSW4JQE32bSDzl2fM49",
	"M09iL2MXEvDiueD68Epm/0EYqCaKdUPhpVJ8JLNfCqjdSvc8fyJptZRrnmu0Vezr7nzt+35cLqqmNPzA",
	"cb7zfdH/mj4xOXgYTwwVBVUFYcXjr7764ut2uZ+ZuBpuUjLuxC3LmeOo4XlX4wurmyHEPCqP1nIoska9",
	"UmrdGumDF2oJ9Y/bqKj9nEkASHq90WJ9dMPZltCI1KVVcEvD25+W9rcN1ZtWdHafK6eCEiev+tFckEfx",
	"aR4Eipgiu1ZUQY89xgRHyySfA2/E4hHpYa5I/C6SJMMSz26JaKC09OKTy2Cv65JZ3a6VgUO+ydW2NvLY",
	"owaPfD/nCR8+exGPl951aAA1K6XVRDBX3CqTrcYFV+kWqgOq5Q325ySGK1VKb6OYthClQ1E26vT057Sy",
	"iSnMae0y3enjnrg96e1pd8dx30Y13PocgbhbXt5BA3cP0nDPP0Ig8Aq0sVwKQ3PQG7GI8uKZMy0tXM3e",
	"xcaYWj89Pr68vDzydqejXFbHa0gayIxs8s2xHwhf7olTa10XV+3OSuFya3iuybM3r0Bn4qZk+AY4uwL7",
	"VqCsxeOjR5iRzQSt+eLp4snRo6MvcMc2QATHtObHF09cRSVtgTp2KadYRTahE/8XMyEtFQwhjWbqF/Th",
	"1AzvOK8KbOjevQGlDUsiwLSPHz1aPP0Am0vtkfl+oRlV+Wbxs/0tBVS/rOYoZPHBvuHaSLV1L2Pgza4p",
	"qZqCOGKob7G7fz4I32J9+n53diqaDTTGSJpGYXyqbftbw2BARy0lr7hZxA8nDnl+rwDzxOIHUYMpQFw0",
	"+yQkP++HRJZBCBwi8zEgEapYHjvARrG4Zr7eZYS/ecj7wXa7R9t10IZ1TGyL5eJYsYJVsAKPxlw2tRQW",
	"m2/Dt046JZppaqlNKvnWdyG05nafLa5xSFIwQzlU0B6gte23pyC5eHwcR8klye0EOqBlw7U9GgCBjV5K",
	"9cwPt4O6/CtaI4iLLMD7ENEd02xbpY2uWTTbEflRs6gUqjyHjCK8/fq8CV/JM3QaAcwOkYKrPYGHZIRr",
	"djdviNWlwrvM1pBDB95OEQWBH3XKDDofi3uXxdVkybekEaW97ni/Ibj7dVgaVKDEciU5dTvgkvd8BLoe",
	"Z1Y/SeYgzCyEe2LEFesHUw3oti5mHszTzpLjKHQZ6svEAT/L9k0/52FbklCxpecaWrqAHf/u8/A5ZQwH",
	"GluwC+fPaFmmlhk5iffDcOlecvpM0WunuBZufahuFIfhnm+C9ULZWIvwc7YdA6bNsh7nrJ0BuNOfx8D3",
	"EsmHv7SP8WD1TajJXTMFQ1odUjGqgTK90R6lqo/AKrimZyW8T4EWuU74zijxhZLBe2AgrmMzLrr7gUt7",
	"n71wbXBW9mi041813gfbAccDvvfJdkrdW31BxsmM7VBLGx2liFcwfNvJGjMeTHJlMjgVhiP/qF14ak3X",
	"XLgQLLBdV/QcTNQC895cBKTnTp+gb4+a4L5zh5OjmBkm5Pb07m7Az8lrXhfyBxAJ9XAxR9s4/uCDX3nx",
	"cVT1eC3leVMHo3z8BMhAA8G2DqPfbIE8JzWQYOr33A7EbG9+ES0HIBfxRhnVsL1O5Lm8f4O8+u95Et6K",
	"wNhDTNyiWEiz4o1xYgn8sYMT55kRemzZd9dO8GX8VsZndv/8THX5qD6GnWXFrxxt+fibXPbqnQmov+uL",
	"wyahAD8+DLa3+oMemTHtJ3z9kJzYp5XFk95Ablxq2/j63ba2+1BCtPqvdrc8/TStnznIX5/9GAyskJmo",
	"+Zpkwd1nf6nwJzAhn/C1/anEn8B5hab71No1X48vXkO3Cv+x481apOPDaCFdv93Z1lXdSOMirZx9loeY",
	"n5IaIlVUBL+duuKu7PzY9KHBjYCAFcP7MNCrHTD4Bvvq3bdiLOmvLFoTvqlkeGXvjU7QUEHevnxOnjx5",
	"8rV7ItRqDEguYwvGITGzOwYuCIyCmvB5jvh5+/I5AHASPCKzWu1EaqCom1o5jPj5LfxPbBr6U9pMPuUl",
	"B1ftVHunC2Opi2n1JBTEuMObwJ/kuj98fu/6z+WNvGThz7nOhDd2eYnuqbMcF3H7cd9Ft9W0/+KmTWF/",
	"VlP2n/Kad8NmjB43zLN9dguu3ts/e0m3t2gDjSY5/tCVEbttod1y0ElbS9skbQdN6QB9SbVTD7g3Pd4U",
	"z+7JqXdngrwlw2OoPrDz1IaWU8EGONSOo/r+IP0T2UtfgsEP7X2+dIU/DfBuHxI527yK5NUrvF1/o7Pb",
	"0UdXS3vWghuYrxHcjM1nv+03340Yom5YkAZxMk/tsc3vFZ6g8HgJekuqDgx//METxm71xiXr73b02obz",
	"1Zs4ofhesblVxUa7ss+zuPAO/akaI0GvQejLxZePvtxrayYfdeq8Afnx48fdSlPESD4KfaeXFkom94sc",
	"Xm4k0Fn8BNsko/nJ7lWte1XrE/oD790X/+7uixs7vG/2VIul7Sw9c/Bg573K6R/Uas+S2zQwxGflPlFN",
	"nUqgcY2sSU30PrDpPrDpPrDpPrDpPrDpPgTpPgTpPgTpPgSpTewV5baNAhrUWY/LJVlAoyJCsch3L4yM",
	"kXqom3pHyVzPZXXGBWu1YL+CNj3LSPfuefd5Fd8QqpV6V9eOdWVKliPnq3+9I9R8Wi78QyVUWT13znnb",
	"WY0HECpeRfPHxb/3WhsUpgQzDfGhX0jLwu5zWW6Jcc86UqsM+pUsCV+RrWzIJTBLyc+hPzx6hvFkFZbl",
	"72bFQU3PZtTH4rpnoYzpLsvP7VuT7+Pl7uPlbjleDp7N0scf8KEtvHju9MWEx0VTt95v7MddN10kA5wu",
	"HXsaA3S39p0p/OHiDtzrWcaGKMphOn0qxDrcWxjuLQz3FoZ7C8O9heE+derebnFvt7i3W9zbLe7tFvd2",
	"i3kRK3dra/ijFQ66t2Z8ftaM5eKrG7zRTwbb9aNWO/XMP1htf3fcKrEXo3LwuFLKdPKu8zb07uBVd92Y",
	"n5n7B2KOw17o34fsPq8Qzzuk6tYuBU8DqQtPYt26y/5flj/Ovvgqe/zof2WPv/w6++LRoyNaZ1o2ZpN9",
	"ceSweEQr+rsU9FJDiebjhaU1N2Eo8ZzLqgJREX5xoES/OJb7+PPH/x8AAP//r2pQ0i4RAQA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
